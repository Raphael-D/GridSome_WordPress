/* eslint-disable no-use-before-define */
import { isType, parse, isOutputType, isInputType } from '../graphql';
import { isFunction } from './is';
import { inspect } from './misc';
import { ObjectTypeComposer } from '../ObjectTypeComposer';
import { InputTypeComposer } from '../InputTypeComposer';
import { ScalarTypeComposer } from '../ScalarTypeComposer';
import { EnumTypeComposer } from '../EnumTypeComposer';
import { InterfaceTypeComposer } from '../InterfaceTypeComposer';
import { UnionTypeComposer } from '../UnionTypeComposer';
import { Resolver } from '../Resolver';
import { NonNullComposer } from '../NonNullComposer';
import { ListComposer } from '../ListComposer';
import { ThunkComposer } from '../ThunkComposer';
export function isTypeNameString(str) {
  return /^[_A-Za-z][_0-9A-Za-z]*$/.test(str);
}
export function isTypeDefinitionString(str) {
  return isOutputTypeDefinitionString(str) || isInputTypeDefinitionString(str) || isEnumTypeDefinitionString(str) || isScalarTypeDefinitionString(str) || isInterfaceTypeDefinitionString(str) || isUnionTypeDefinitionString(str);
}
export function isSomeOutputTypeDefinitionString(str) {
  return isOutputTypeDefinitionString(str) || isEnumTypeDefinitionString(str) || isScalarTypeDefinitionString(str) || isInterfaceTypeDefinitionString(str) || isUnionTypeDefinitionString(str);
}
export function isSomeInputTypeDefinitionString(str) {
  return isInputTypeDefinitionString(str) || isEnumTypeDefinitionString(str) || isScalarTypeDefinitionString(str);
}
export function isOutputTypeDefinitionString(str) {
  return /type\s[^{]+\{[^}]+\}/im.test(str);
}
export function isInputTypeDefinitionString(str) {
  return /input\s[^{]+\{[^}]+\}/im.test(str);
}
export function isEnumTypeDefinitionString(str) {
  return /enum\s[^{]+\{[^}]+\}/im.test(str);
}
export function isScalarTypeDefinitionString(str) {
  return /scalar\s/im.test(str);
}
export function isInterfaceTypeDefinitionString(str) {
  return /interface\s/im.test(str);
}
export function isUnionTypeDefinitionString(str) {
  return /union\s/im.test(str);
}
export function isSomeOutputTypeComposer(type) {
  return type instanceof ObjectTypeComposer || type instanceof InterfaceTypeComposer || type instanceof EnumTypeComposer || type instanceof UnionTypeComposer || type instanceof ScalarTypeComposer || type instanceof NonNullComposer && isSomeOutputTypeComposer(type.ofType) || type instanceof ListComposer && isSomeOutputTypeComposer(type.ofType) || type instanceof ThunkComposer;
}
export function isSomeInputTypeComposer(type) {
  return type instanceof InputTypeComposer || type instanceof EnumTypeComposer || type instanceof ScalarTypeComposer || type instanceof NonNullComposer && isSomeInputTypeComposer(type.ofType) || type instanceof ListComposer && isSomeInputTypeComposer(type.ofType) || type instanceof ThunkComposer;
}
export function isComposeType(type) {
  return isType(type) || Array.isArray(type) && isComposeType(type[0]) || type instanceof ObjectTypeComposer || type instanceof InputTypeComposer || type instanceof InterfaceTypeComposer || type instanceof EnumTypeComposer || type instanceof UnionTypeComposer || type instanceof ScalarTypeComposer || type instanceof Resolver;
}
export function isComposeOutputType(type) {
  return isOutputType(type) || Array.isArray(type) && isComposeOutputType(type[0]) || isSomeOutputTypeComposer(type) || type instanceof Resolver;
}
export function isComposeInputType(type) {
  return isInputType(type) || Array.isArray(type) && isComposeInputType(type[0]) || isSomeInputTypeComposer(type);
}
export function isNamedTypeComposer(type) {
  return type instanceof ObjectTypeComposer || type instanceof InputTypeComposer || type instanceof ScalarTypeComposer || type instanceof EnumTypeComposer || type instanceof InterfaceTypeComposer || type instanceof UnionTypeComposer;
}
export function isTypeComposer(type) {
  return isNamedTypeComposer(type) || type instanceof ListComposer || type instanceof NonNullComposer || type instanceof ThunkComposer;
}
export function getGraphQLType(anyType) {
  let type = anyType; // extract type from ObjectTypeComposer, InputTypeComposer, EnumTypeComposer and Resolver

  if (type && isFunction(type.getType)) {
    type = type.getType();
  }

  if (!isType(type)) {
    throw new Error(`You provide incorrect type for 'getGraphQLType' method: ${inspect(type)}`);
  }

  return type;
}
export function getComposeTypeName(type) {
  if (typeof type === 'string') {
    if (/^[_a-zA-Z][_a-zA-Z0-9]*$/.test(type)) {
      // single type name
      return type;
    } else {
      // parse type name from `type Name { f: Int }`
      const docNode = parse(type);

      if (docNode.definitions[0] && docNode.definitions[0].name && typeof docNode.definitions[0].name.value === 'string') {
        return docNode.definitions[0].name.value;
      }
    }

    throw new Error(`Cannot get type name from string: ${inspect(type)}`);
  } else if (isFunction(type)) {
    return getComposeTypeName(type());
  } else {
    try {
      const gqlType = getGraphQLType(type);

      if (typeof gqlType.name === 'string') {
        return gqlType.name;
      }
    } catch (e) {
      throw new Error(`Cannot get type name from ${inspect(type)}`);
    }
  }

  throw new Error(`Cannot get type name from ${inspect(type)}`);
}
export function unwrapTC(anyTC) {
  if (anyTC instanceof NonNullComposer || anyTC instanceof ListComposer || anyTC instanceof ThunkComposer) {
    const unwrappedTC = anyTC.getUnwrappedTC();
    return unwrapTC(unwrappedTC);
  }

  return anyTC;
}
export function unwrapInputTC(inputTC) {
  return unwrapTC(inputTC);
}
export function unwrapOutputTC(outputTC) {
  return unwrapTC(outputTC);
}
export function changeUnwrappedTC(anyTC, cb) {
  let tc = anyTC;
  const wrappers = [];

  while (tc instanceof ListComposer || tc instanceof NonNullComposer || tc instanceof ThunkComposer) {
    if (tc instanceof ThunkComposer) {
      tc = tc.getUnwrappedTC();
    } else {
      wrappers.unshift(tc.constructor);
      tc = tc.ofType;
    }
  } // call callback for TC


  tc = cb(tc);

  if (tc) {
    // wrap TypeComposer back
    tc = wrappers.reduce((type, Wrapper) => new Wrapper(type), tc);
  }

  return tc;
}